package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/Jeffail/gabs"
	cli "github.com/jawher/mow.cli"
)

func grafanaCmd(c *cli.Cmd) {
	rowName := c.StringOpt("R row", "Ads Service", "Specifies a row name to use as a template.")
	inFile := c.StringArg("DASHBOARD", "dashboard.json", "Specify path to the dashboard JSON file.")
	outFile := c.StringOpt("o out", "dashboard_gen.json", "Specify path for the generated output.")

	c.Action = func() {
		_ = *outFile
		servicesRoot := filepath.Join(*projectDir, "core")
		services := scanMetricTagsAll(servicesRoot)
		counts := make(map[string]int)
		for _, layers := range services {
			for name := range layers {
				switch name {
				case "data", "service", "handler":
					counts[name]++
				default:
					counts["unknown"]++
				}
			}
		}
		log.Printf("Found %d services", len(services))
		if len(services) == 0 {
			return
		}
		log.Printf("Found %d data layers, %d service layers, %d handler layers, %d unknown",
			counts["data"], counts["service"], counts["handler"], counts["unknown"])
		if len(counts) == 0 {
			return
		}
		data, err := ioutil.ReadFile(*inFile)
		if err != nil {
			log.Fatalln("Error opening dashboard:", err)
		}
		dash, err := gabs.ParseJSON(data)
		if err != nil {
			log.Fatalln("Error decoding dashboard:", err)
		}
		ts := fmt.Sprintf("Autogenerated by core_gen, do not edit! %s", time.Now().Format(time.RFC3339))
		dash.Set(ts, "description")
		rows, _ := dash.Search("rows").Children()
		if len(rows) == 0 {
			log.Fatalln("Error: no rows found in dashboard")
		}
		var row *gabs.Container
		for _, r := range rows {
			titleStr := r.S("title").Data().(string)
			if titleStr == *rowName {
				row = r
				break
			}
		}
		if row == nil {
			log.Fatalf("No reference row with name %s found in dashboard", *rowName)
		}
		names := sortedServiceNames(services)
		dash.Array("rows")
		for _, name := range names {
			r := copyRow(row)
			layers := services[name]
			craftPanels(r, name, layers)
			dash.ArrayAppend(r.Data(), "rows")
		}
		outData := dash.BytesIndent("", "\t")
		if err := ioutil.WriteFile(*outFile, outData, 0600); err != nil {
			log.Fatalln("Error writing output:", err)
		}
		log.Println("Done")
	}
}

func craftPanels(row *gabs.Container, name string, layers map[string]bool) {
	rowName := strings.Replace(name, "_", " ", -1)
	rowName = strings.Replace(rowName, ".", " ", -1)
	rowName = strings.Title(rowName)
	rowName = strings.Replace(rowName, " ", "", -1)
	row.Set(rowName, "title")
	row.Set(200, "height")
	// row.Set(true, "collapse")

	panels, _ := row.S("panels").Children()
	row.Array("panels")
	for _, p := range panels {
		if n, err := p.ArrayCount("targets"); err != nil || n == 0 {
			continue
		}
		targetTags, _ := p.S("targets").Index(0).S("tags").Children()
		var targetLayer string
		for _, tag := range targetTags {
			switch key := tag.S("key").Data().(string); key {
			case "service":
				tag.Set(name, "value")
			case "layer":
				targetLayer = tag.S("value").Data().(string)
			}
		}
		if len(targetLayer) == 0 || !layers[targetLayer] {
			continue
		}
		row.ArrayAppend(p.Data(), "panels")
	}
}

func copyRow(row *gabs.Container) *gabs.Container {
	newRow, _ := gabs.ParseJSON([]byte(row.String()))
	return newRow
}

func sortedServiceNames(services map[string]map[string]bool) []string {
	names := make([]string, 0, len(services))
	for name := range services {
		names = append(names, name)
	}
	sort.Strings(names)
	return names
}
